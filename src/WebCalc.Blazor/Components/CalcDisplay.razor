@using System.Drawing
@using WebCalc.Application.BinaryOperation
@using WebCalc.Application.Contracts.BinaryOperation
@using WebCalc.Contracts
@using WebCalc.Domain.BinaryOperation
@using WebCalc.Domain.Shared
@implements ICalcDisplay

<div id="display">
    <div id="memory" class="display-component">
        <p id="memory-paragraph">
            <span id="memory-capture">Memory:</span>
            <span id="memory-value">@memory</span>
        </p>
    </div>
    <div id="value" class="display-component">
        <p id="value-holder">@value</p>
    </div>
    <div id="expression" class="display-component">
        <p id="expression-value">@expression</p>
    </div>
</div>

<style>
    #display {
        background: white;
        margin-bottom: 10px;
    }

    .display-component>p{
        margin-bottom: 0; /*Overwrite display's margin-bottom rule*/
    }

    #memory-paragraph {
        visibility:@visibilityValue;
        margin-left: 5px;
    }

    #memory-capture {
        background: @MemoryColor.Name;
        color: white;
    }

    #memory-value {
        color: @MemoryColor.Name;
    }

    #value-holder {
        text-align: right;
        color: @ValueColor.Name;
    }

    #expression-value {
        text-align: right;
        color: @ExpressionColor.Name;
    }

    #expression-value:empty::before {
        content: "";
        display: inline-block;
    }

    @@media (max-width:280px) {
        #memory-paragraph {
            font-size: 16px;
        }

        #value-holder {
            font-size: 22px;
        }

        #expression-value {
            font-size: 16px;
        }
    }

    @@media (min-width:281px) {
        #memory-paragraph {
            font-size: 22px;
        }

        #value-holder {
            font-size: 32px;
        }

        #expression-value {
            font-size: 22px;
        }
    }
</style>

@code {
    private const string INITIAL_STRING = "0";
    private string value = INITIAL_STRING;
    private string expression = string.Empty;
    private string memory = string.Empty;
    private bool memoryRead;
    private const string HIDDEN = "hidden";
    private const string NONE = "none";
    private string visibilityValue = HIDDEN;

    public bool PercentageOff { get; private set; }

    [Parameter]
    public int MaxDisplayCharsCount { get; set; } = 15;

    [Parameter]
    public int MaxFractionalDigitsCount { get; set; } = 9;

    [Parameter]
    public EventCallback<float> OnValidOperandGenerated { get; set; }

    [Parameter]
    public EventCallback<OperationType> OnOperationTypeChanged { get; set; }

    [Parameter]
    public Color MemoryColor { get; set; } = Color.Green;

    [Parameter]
    public Color ExpressionColor { get; set; } = Color.Red;

    [Parameter]
    public Color ValueColor { get; set; } = Color.Black;

    public void SetMemory(string memory)
    {
        if (memory == "0") return;

        this.memory = memory;
        visibilityValue = NONE;

        StateHasChanged();
    }

    public void ClearMemory()
    {
        memory = string.Empty;
        visibilityValue = HIDDEN;

        StateHasChanged();
    }

    public void ReadMemory()
    {
        value = memory;
        memoryRead = true;

        StateHasChanged();
    }

    public string Value => value;

    public string Expression => expression;

    public string Memory => memory;

    public void Clear()
    {
        value = INITIAL_STRING;
        expression = string.Empty;
        memoryRead = false;

        StateHasChanged();
    }

    /// <summary>
    /// When passing "=" sign, value is cleared
    /// </summary>
    /// <param name="char"></param>
    /// <returns></returns>
    public async Task AppendAsync(char @char)
    {
        ClearValueIfNeeded(@char);

        var oldValue = value;

        if (@char == Constants.BACKSPACE && memoryRead) return;

        if (@char == Constants.BACKSPACE)
        {
            value = GetValidOperand(GetBackspaced(value));
        }
        else
        {
            value = GetValidOperand(memoryRead ? INITIAL_STRING : value, @char);
            memoryRead = false;
        }

        if (oldValue != value)
        {
            await OnValidOperandGenerated.InvokeAsync(float.Parse(value));
        }

        expression = GetValidExpression(expression, @char);

        if (@char == '=')
        {
            value = INITIAL_STRING;
        }

        StateHasChanged();
    }

    public void Append(char[] chars)
    {
        var temp = new string(chars);

        value = GetValidOperand(temp);
        if (!expression.Contains('='))
        {
            expression = GetValidOperand(temp);
        }

        StateHasChanged();
    }

    private void ClearValueIfNeeded(char @char)
    {
        (string? firstOperand, char? operationType, string? secondOperand) = GetExpressionComponents(expression);

        if (operationType is not null && string.IsNullOrWhiteSpace(secondOperand) && (char.IsDigit(@char) || @char == Constants.FLOATING_POINT))
        {
            value = INITIAL_STRING;
        }
    }

    private string GetValidExpression(string expression, char @char)
    {
        (string? firstOperand, char? operationType, string? secondOperand) = GetExpressionComponents(expression);

        if (@char == '=')
        {
            if (PercentageOff)
            {
                PercentageOff = false;
                return expression = $"{firstOperand}-{firstOperand}*0,{secondOperand}=";
            }
            else
            {
                return expression += @char;
            }
        }
        else if (firstOperand is not null && @char == Constants.PERCENTAGE_OFF)
        {
            OnOperationTypeChanged.InvokeAsync(OperationType.Subtraction);
            operationType = '-';
            PercentageOff = true;
        }
        else if (firstOperand is not null && string.IsNullOrWhiteSpace(secondOperand) && (@char == '+' || @char == '-' || @char == '/' || @char == '*'))
        {
            OnOperationTypeChanged.InvokeAsync(GetOperationType(@char));
            operationType = @char;
        }
        else if (operationType is null)
        {
            if (@char == Constants.BACKSPACE)
            {
                firstOperand = GetValidOperand(GetBackspaced(string.IsNullOrWhiteSpace(firstOperand) ? "0" : firstOperand));
            }
            else if (@char == Constants.NEGATION_OPERATION_SIGN)
            {
                firstOperand = firstOperand!.Contains('-') ? firstOperand.Trim('(', ')', '-') : $"(-{firstOperand})";
            }
            else
            {
                firstOperand = GetValidOperand(string.IsNullOrWhiteSpace(firstOperand) ? "0" : firstOperand, @char);
            }
        }
        else
        {
            if (@char == Constants.BACKSPACE)
            {
                secondOperand = GetValidOperand(GetBackspaced(string.IsNullOrWhiteSpace(secondOperand) ? "0" : secondOperand));
            }
            else if (@char == Constants.NEGATION_OPERATION_SIGN)
            {
                secondOperand = secondOperand!.Contains('-') ? secondOperand.Trim('(', ')', '-') : $"(-{secondOperand})";
            }
            else
            {
                secondOperand = GetValidOperand(string.IsNullOrWhiteSpace(secondOperand) ? "0" : secondOperand, @char);
            }
        }

        return string.Concat(firstOperand, operationType, secondOperand);
    }

    private (string?, char?, string?) GetExpressionComponents(string expression)
    {
        var operands = new string[2];
        var operationTypeIndex = 0;
        if (expression.FirstOrDefault() == '(')
        {
            operands = expression.Split(new[] { ")-", ")+", ")/", ")*" }, 2, StringSplitOptions.RemoveEmptyEntries);

            if (operands[0].Last() != ')')
            {
                operands[0] = $"{operands[0]})";
            }

            var tempIndex = expression.IndexOf(')') + 1;
            var operationType = expression.ElementAtOrDefault(tempIndex);

            if (operationType == default)
            {
                operationTypeIndex = -1;
            }
            else
            {
                operationTypeIndex = tempIndex;
            }
        }
        else
        {
            operands = expression.Split(new[] { '+', '-', '*', '/' }, 2);
            operationTypeIndex = expression.IndexOfAny(new[] { '+', '-', '*', '/' });
        }


        if (operands.ElementAtOrDefault(1) is string secondOperand)
        {
            return (operands[0], expression[operationTypeIndex], secondOperand);
        }
        else if (operationTypeIndex > 0)
        {
            return (operands[0], expression[operationTypeIndex], null);
        }
        else
        {
            return (operands[0], null, null);
        }
    }

    private string GetValidOperand(string source, char? @char = null)
    {
        string temp = string.Empty;

        if (@char is null)
            temp = source;
        else if (source == INITIAL_STRING && @char != Constants.FLOATING_POINT)
            temp += @char;
        else if (@char == Constants.NEGATION_OPERATION_SIGN)
            temp = source.Contains('-') ? source.Trim('-') : $"-{source}";
        else if (@char == Constants.FLOATING_POINT && source.Contains(Constants.FLOATING_POINT))
            temp = source;
        else
            temp = source + @char;

        if (float.TryParse(temp, out float res))
            return temp;
        else
            return source;
    }

    private string GetBackspaced(string source)
    {
        var result = source.Substring(0, source.Length - 1);

        if (string.IsNullOrWhiteSpace(result))
        {
            result = "0";
        }

        return result;
    }

    private OperationType GetOperationType(char value)
    {
        switch (value)
        {
            case '+':
                return OperationType.Addition;
            case '-':
                return OperationType.Subtraction;
            case '*':
                return OperationType.Multiplication;
            case '/':
                return OperationType.Division;
            default:
                throw new ArgumentException();
        }
    }
}